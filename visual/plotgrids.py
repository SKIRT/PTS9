#!/usr/bin/env python
# -*- coding: utf8 -*-
# *****************************************************************
# **       PTS -- Python Toolkit for working with SKIRT          **
# **       Â© Astronomical Observatory, Ghent University          **
# *****************************************************************

## \package pts.visual.plotgrids Plot a spatial grid wireframe produced by SKIRT
#
# The function in this module creates a PDF plot from a sequence of grid coordinates
# provided as a text file in the format generated by SKIRT's SpatialGridPlotProbe class.
# The function directly creates a PDF file through the reportlab module, without using matplotlib.

# -----------------------------------------------------------------

import logging
import numpy as np
import reportlab.pdfgen.canvas
import pts.simulation as sm
import pts.utils as ut

# -----------------------------------------------------------------

## This function creates a wireframe plot for one or more text files generated by SKIRT's SpatialGridPlotProbe class.
# The function accepts a sequence of Simulation and/or Probe instances (or a single instance of either of these types),
# and creates a plot file in PDF format for each "*_grid_NN.dat" file produced by any of these simulations/probes.
# The plot files have the same name as the corresponding input file, and with a ".pdf" filename extension.
# By default the plot files are placed next to the corresponding input file in the same directory, but another output
# directory can be specified if needed.
#
# There are two format variations for 2D and 3D information, respectively. The 2D format describes the
# intersection of a dust grid structure with one of the coordinate planes. The 3D format fully describes
# all or part of the dust cells in the grid. Each line in the file contains two (2D) or three (3D)
# coordinates seperated by whitespace, or is empty. Consecutive nonempty lines represent a sequence of
# "lineto" commands; an empty line marks a "moveto" command.
#
def plotGrids(simulation, *, lineWidth=0.1, plotDirPath=None, figSize=(8, 8)):

    # loop over the (probe, output file path) tuples
    for probe, gridFilePath in sm.probeOutFilePaths(simulation, "grid_*.dat"):

        # determine output file path
        plotFilePath = gridFilePath.with_suffix(".pdf")
        if plotDirPath is not None: plotFilePath = ut.absPath(plotDirPath) / plotFilePath.name

        # determine the format type from the first nonempty line (3D format has 3 columns, 2D format has 2 columns)
        with open(gridFilePath) as gridfile:
            for line in gridfile:
                form = len(line.split())
                if form > 0: break

        # use 2D or 3D version
        if form == 2:
            _plotGrid2D(gridFilePath, plotFilePath, lineWidth, figSize)
        else:
            _plotGrid3D(gridFilePath, plotFilePath, lineWidth, figSize)


# -----------------------------------------------------------------

def _createFigure(plotFilePath, lineWidth, figSize):

    # setup the figure with the appropriate size (in points)
    figwidth = 72 * figSize[0]
    figheight = 72 * figSize[1]
    if figwidth == figheight: figheight += 2  # to ensure portrait orientation when printed
    fig = reportlab.pdfgen.canvas.Canvas(str(plotFilePath), pagesize=(figwidth, figheight))
    fig.setAuthor("Python toolkit for SKIRT")
    fig.setLineWidth(lineWidth)

    # return the reportlab canvas and the configured size
    return fig, figwidth, figheight

# -----------------------------------------------------------------

def _plotGrid2D(gridFilePath, plotFilePath, lineWidth, figSize):

    # create the reportlab canvas
    fig, figwidth, figheight = _createFigure(plotFilePath, lineWidth, figSize)

    # determine the extent of the grid being plotted
    xmin, ymin, xmax, ymax = float('Inf'), float('Inf'), float('-Inf'), float('-Inf')
    with open(gridFilePath) as gridfile:
        for line in gridfile:
            coords = line.split()
            if len(coords) == 2:
                x, y = float(coords[0]), float(coords[1])
                xmin, ymin, xmax, ymax = min(xmin, x), min(ymin, y), max(xmax, x), max(ymax, y)

    # determine the scales and offsets to fit and center the grid in the figure
    xs = figwidth * 0.95 / (xmax - xmin)
    ys = figheight * 0.95 / (ymax - ymin)
    xo = (figwidth - xs * (xmax - xmin)) / 2. - xmin * xs
    yo = (figheight - ys * (ymax - ymin)) / 2. - ymin * ys

    # for each set of consecutive nonempty lines in the file, draw the line segments
    path = None
    with open(gridFilePath) as gridfile:
        for line in gridfile:
            coords = line.split()
            if len(coords) == 0 and path is not None:
                fig.drawPath(path)
                path = None
            if len(coords) == 2:
                x, y = xo + xs * float(coords[0]), yo + ys * float(coords[1])
                if path is None:
                    path = fig.beginPath()
                    path.moveTo(x, y)
                else:
                    path.lineTo(x, y)

    # save the figure
    fig.showPage()
    fig.save()
    logging.info("Created grid plot {}".format(plotFilePath))

# -----------------------------------------------------------------

def _plotGrid3D(gridFilePath, plotFilePath, lineWidth, figSize):

    # create the reportlab canvas
    fig, figwidth, figheight = _createFigure(plotFilePath, lineWidth, figSize)

    # determine the extent of the grid being plotted (largest half-width in all directions)
    extent = 0.
    with open(gridFilePath) as gridfile:
        for line in gridfile:
            coords = line.split()
            if len(coords) == 3:
                extent = max(extent, max([ abs(float(c)) for c in coords ]))

    # determine the scale and offsets to fit and center the grid in the figure
    s = min(figwidth, figheight) * 0.95 / (2 * extent) / np.sqrt(3)
    xo = extent * s + (figwidth - s * (2 * extent)) / 2.
    yo = extent * s + (figheight - s * (2 * extent)) / 2.

    # set the viewing angles
    inclination, azimuth = 65, 40
    costheta = np.cos(inclination * np.pi / 180.)
    sintheta = np.sin(inclination * np.pi / 180.)
    cosphi = np.cos(azimuth * np.pi / 180.)
    sinphi = np.sin(azimuth * np.pi / 180.)

    # for each set of consecutive nonempty lines in the file, draw the line segments
    path = None
    with open(gridFilePath) as gridfile:
        for line in gridfile:
            coords = line.split()
            if len(coords) == 0 and path is not None:
                fig.drawPath(path)
                path = None
            if len(coords) == 3:
                x, y, z = map(float, coords)
                xp = - sinphi * x + cosphi * y
                yp = - cosphi * costheta * x - sinphi * costheta * y + sintheta * z
                xf = xo + s * xp
                yf = yo + s * yp
                if path is None:
                    path = fig.beginPath()
                    path.moveTo(xf, yf)
                else: path.lineTo(xf, yf)

    # save the figure
    fig.showPage()
    fig.save()
    logging.info("Created grid plot {}".format(plotFilePath))

# -----------------------------------------------------------------
