#!/usr/bin/env python
# -*- coding: utf8 -*-
# *****************************************************************
# **       PTS -- Python Toolkit for working with SKIRT          **
# **       Â© Astronomical Observatory, Ghent University          **
# *****************************************************************

## \package pts.simulation.simulation Representing the files related to a SKIRT simulation
#
# An instance of the Simulation class in this module represents all input and output files
# related to a single performed SKIRT simulation.

# -----------------------------------------------------------------

import astropy.units as u
import os
import pts.utils as ut
import numpy as np
from .skifile import SkiFile
from .text import loadColumns
from .fits import getFitsAxes

# -----------------------------------------------------------------

## This function returns a list of Simulation objects corresponding to SKIRT output in the specified directory,
# optionally restricted to the simulation with the specified prefix. The function detects SKIRT output based on
# the primary log file generated by each simulation. The arguments are as follows.
#  - \em outDirPath: path to the directory to be searched, as described for the pts.utils.absPath() function.
#    A missing argument or the empty string indicates the current working directory.
#  - \em prefix: if specified, the search is restricted to the simulation with the specified prefix (corresponding
#    to the stem of the ski filename passed to SKIRT). If omitted or None, all simulations in the directory are
#    included.
#
# If no simulation output conforming to the specified requirements is found, the function returns an empty list.
# The Simulation objects created by this function have no knowledge about any of the input files of the simulation.
#
def createSimulations(outDirPath="", prefix=None):
    simulations = []

    # loop over the log files in the specified directory
    for logfile in ut.absPath(outDirPath).glob("*_log.txt"):
        if prefix is None or prefix == logfile.stem[:-4]:
            simulations += [ Simulation(outDirPath=logfile.parent, prefix=logfile.stem[:-4]) ]

    return simulations

## This function returns a single Simulation object corresponding to SKIRT output in the specified directory,
# optionally restricted to the simulation with the specified prefix. The function calls the createSimulations()
# function, verifies that there is exactly one item in the returned list, and returns that item. If no simulation
# is found, or multiple simulations are found, the function raises an error.
#
def createSimulation(outDirPath="", prefix=None):
    simulations = createSimulations(outDirPath, prefix)
    if len(simulations) == 0:
        raise ValueError("No simulations were found for the specified directory and prefix")
    elif len(simulations) > 1:
        raise ValueError("Multiple simulations were found for the specified directory and prefix")
    return simulations[0]

# -----------------------------------------------------------------

## This function accepts a sequence of Simulation and/or Instrument instances, or a single instance of either of
# these types. It iterates over these entities looking for associated instrument output files that have a name with
# a final segment that ends in the specified string (or all output files if the \em fileType argument is omitted).
# The function returns a list of tuples, each containing an Instrument instance and an associated output file path.
# The list follows the order of the specified input entities. The list may be empty.
#
def instrumentOutFilePaths(entities, fileType=None):
    # when given a single entity, create a sequence containing it
    if isinstance(entities, Simulation) or isinstance(entities, Instrument):
        entities = [ entities ]

    # loop over all entities and assemble the result list
    result = []
    for entity in entities:
        # convert the entity in a list of instruments
        if isinstance(entity, Simulation):
            instruments = entity.instruments()
        elif isinstance(entity, Instrument):
            instruments = [ entity ]
        else:
            raise ValueError("Entity is not a simulation or instrument: {}".format(type(entity)))

        # loop over the instruments
        for instrument in instruments:
            filepaths = instrument.outFilePaths(fileType)
            result += [ (instrument,filepath) for filepath in filepaths ]

    return result

## This function accepts a sequence of Simulation and/or Probe instances, or a single instance of either of
# these types. It iterates over these entities looking for associated probe output files that have a name with
# a final segment that ends in the specified string (or all output files if the \em fileType argument is omitted).
# The function returns a list of tuples, each containing a Probe instance and an associated output file path.
# The list follows the order of the specified input entities. The list may be empty.
#
def probeOutFilePaths(entities, fileType=None):
    # when given a single entity, create a sequence containing it
    if isinstance(entities, Simulation) or isinstance(entities, Probe):
        entities = [ entities ]

    # loop over all entities and assemble the result list
    result = []
    for entity in entities:
        # convert the entity in a list of probes
        if isinstance(entity, Simulation):
            probes = entity.probes()
        elif isinstance(entity, Probe):
            probes = [ entity ]
        else:
            raise ValueError("Entity is not a simulation or probe: {}".format(type(entity)))

        # loop over the probes
        for probe in probes:
            filepaths = probe.outFilePaths(fileType)
            result += [ (probe,filepath) for filepath in filepaths ]

    return result

# -----------------------------------------------------------------

## An instance of the Simulation class represents all input and output files related to a single performed
# SKIRT simulation. To create an instance of the class, one specifies the name of the ski file (used as prefix
# for all output filenames) plus directory paths for the input and output files.
# The methods of the class allow retrieving all kinds of information about the simulation results.
#
# The code in this class uses ad-hoc knowledge about SKIRT's data formats and naming schemes; for example:
#  - SKIRT's hard-coded output file names are used to locate various output files.
#  - the structure of the SKIRT parameter file (ski file) is used to determine things like
#    the names of the instruments and probes in the simulation.
#  - the format of the log file is used to extract success or error messages.
#
class Simulation:

    ## The constructor accepts the following arguments:
    # - \em prefix: the name of the ski file for which the simulation was performed (without the directory path and
    #   without the \c .ski filename extension) and which has been used as a prefix for all output file names.
    #   If the prefix argument is empty or missing, the skiFilePath argument must be provided so that the prefix
    #   can be automatically derived from the (stem of the name of) the specified ski file.
    # - \em skiFilePath: the path of the input ski file for which the simulation was performed (\em not the
    #   \c parameters.xml file generated by SKIRT). This argument is optional, but if it is omitted, the prefix
    #   argument must be present and non-empty.
    # - \em inDirPath: the input path of the simulation. If there were no input files for the simulation, or if
    #   access to the input files is not needed, this argument may be omitted.
    # - \em outDirPath: the output path of the simulation. If this argument is missing, the output path is taken to
    #   be the current working directory.
    # - \em process: optional subprocess.Popen object that can be queried for completion of a simulation.
    #   If the argument is not provided, the completion status is derived from the log file.
    #   This argument is provided by the Skirt object when it creates a Simulation instance for a simulation
    #   that is being performed in asynchronous mode.
    #
    # All paths described above are interpreted as described for the pts.utils.absPath() function.
    #
    def __init__(self, prefix="", *, skiFilePath=None, inDirPath=None, outDirPath="", process=None):

        if len(prefix)==0 and skiFilePath is None:
            raise ValueError("Simulation constructor must specify prefix or ski file path")

        # remember the absolute paths and the prefix
        self._skiFilePath = ut.absPath(skiFilePath) if skiFilePath is not None else None
        self._inDirPath = ut.absPath(inDirPath) if inDirPath is not None else None
        self._outDirPath = ut.absPath(outDirPath)
        self._prefix = prefix if len(prefix)>0 else self._skiFilePath.stem

        # remember the process, if provided, and its completion status
        self._process = process
        self._running = 'true' if process is not None else 'unknown'

        # provide placeholders for caching frequently-used objects
        self._parameters = None

    # -----------------------------------------------------------------

    ## This function returns the prefix for the simulation, which is used for all output file names.
    def prefix(self):
        return self._prefix

    ## This function returns the absolute file path of the input ski file for which the simulation was performed
    # (not the \c parameters.xml file generated by SKIRT), or None if it is unknown.
    def skiFilePath(self):
        return self._skiFilePath

    ## This function returns the absolute path to the input directory of the simulation, or None if it is unknown.
    def inDirPath(self):
        return self._inDirPath

    ## This function returns the absolute path to the output directory of the simulation.
    def outDirPath(self):
        return self._outDirPath

    ## This function returns the absolute path for a simulation input file, given the file's name,
    # or None if the input directory path is unknown.
    def inFilePath(self, name):
        if self._inDirPath is not None:
            return self._inDirPath / name
        else:
            return None

    ## This function returns the absolute path for a simulation output file, given the file's partial name
    # (the partial name does not include the prefix and the subsequent underscore).
    def outFilePath(self, partialname):
        return self._outDirPath / (self._prefix + "_" + partialname)

    ## This function returns the absolute path for the simulation log file.
    def logFilePath(self):
        return self.outFilePath("log.txt")

    ## This function returns a list of absolute filepaths for all log files produced by the simulation, including
    # the master log file and any log files produced by parallel (MPI) processes. The list includes only paths for
    # log files that actually exist, and the paths are listed in order of process rank.
    def logFilePaths(self):
        return sorted(self._outDirPath.glob(self._prefix + "_log*.txt"))

    # -----------------------------------------------------------------

    ## This function returns the status of the simulation, based on its process completion state (if available)
    # and the contents of its log file, as one of the following strings:
    #  - 'NotStarted': the simulation has not (yet) been started.
    #  - 'Running': the simulation is still running, or at least it seems to be so (for example, the simulation
    #    crashed without logging an error message and the Simulation was constructed without a project object).
    #  - 'Crashed': the simulation ended with a fatal error.
    #  - 'Finished': the simulation completed properly.
    def status(self):

        # if we were given a process object, and we still have it, query it
        if self._process is not None:
            if self._process.poll() is None:
                return "Running"
            else:
                # allow the process object to be freed
                self._process = None
                self._running = 'false'

        # the process has finished (running==false) or we weren't given a process object (running==unknown)

        # handle log file not found
        logpath = self.logFilePath()
        if not logpath.is_file():
            return "NotStarted"

        # get the last two lines of the file (assume the relevant portion is not longer than 500 characters)
        with open(logpath, 'rb') as logfile:
            logfile.seek(0, os.SEEK_END)
            logfile.seek(-min(logfile.tell(),500), os.SEEK_END)
            chunk = logfile.read()
        lines = chunk.splitlines()
        last = lines[-1] if len(lines)>0 else b""
        lastbutone = lines[-2] if len(lines)>1 else b""

        # handle contents of the last lines
        if b" Available memory: " in last: last = lastbutone
        if b" Finished simulation " + bytes(self._prefix,'utf8') in last: return "Finished"
        if b" *** Error: " in last: return "Crashed"
        if self._running == 'false': return "Crashed"
        return "Running"   # we don't know for sure, but we can hope

    # -----------------------------------------------------------------

    ## This function returns a SkiFile object representing the parameter file for this simulation.
    def parameters(self):
        if self._parameters is None:
            self._parameters = SkiFile(self.outFilePath("parameters.xml"))
        return self._parameters

    ## This function allows invoking any SkiFile function directly on a simulation object. For example,
    # self.instrumentNames() is automatically translated to self.parameters().instrumentNames().
    def __getattr__(self, attrname):
        # if this is not a system attribute
        if not attrname.startswith("__"):
            # attempt delegating to our SkiFile object
            try: return getattr(self.parameters(), attrname)
            except AttributeError: pass
        raise AttributeError("Can't delegate this attribute")

    # -----------------------------------------------------------------

    ## This function returns a list of Instrument instances for each of the instruments in the simulation,
    # in their order of appearance in the ski file.
    def instruments(self):
        return [ Instrument(self, index) for index in range(len(self.instrumentNames())) ]

    ## This function returns a list of Probe instances for each of the probes in the simulation,
    # in their order of appearance in the ski file.
    def probes(self):
        return [ Probe(self, index) for index in range(len(self.probeNames())) ]

# -----------------------------------------------------------------

## This class serves as an abstract base class for the Instrument and Probe classes. Instances of these classes
# can be spawned from a Simulation object to represent one of those entities and allow retrieving attributes.
# This base class implements some common functionality.
class _SimulationEntity:
    ## The constructor accepts the Simulation instance in which this entity resides, and the xpath of the entity
    # in the ski file for the simulation.
    # It is intended to be invoked only from within the constructor of a subclass.
    def __init__(self, simulation, xpath):
        self._simulation = simulation
        self._xpath = xpath

    ## This function returns the prefix for the simulation with which this entity is associated. The prefix
    # is used as the initial segment of all output file names.
    def prefix(self):
        return self._simulation.prefix()

    ## This function returns the type of the entity, i.e. the corresponding SKIRT class name, as a string.
    def type(self):
        return self._simulation.getStringAttribute(self._xpath, None)

    ## This function returns the value of the specified entity attribute as a string.
    # If the entity does not have the specified attribute, an error is raised.
    def getStringAttribute(self, attribute):
        return self._simulation.getStringAttribute(self._xpath, attribute)

    ## This function returns the value of the specified entity attribute as a Boolean value. The string value is
    # considered to represent True if it contains "true", "t", "yes", "y" or "1" (case insensitive),
    # and False otherwise.
    # If the entity does not have the specified attribute, an error is raised.
    def getBoolAttribute(self, attribute):
        return self._simulation.getBoolAttribute(self._xpath, attribute)

    ## This function returns the value of the specified entity attribute as an integer number.
    # If the entity does not have the specified attribute, an error is raised.
    def getIntAttribute(self, attribute):
        return self._simulation.getIntAttribute(self._xpath, attribute)

    ## This function returns the value of the specified entity attribute as a floating point number
    # representing a dimensionless quantity.
    # If the entity does not have the specified attribute, an error is raised.
    def getFloatAttribute(self, attribute):
        return self._simulation.getFloatAttribute(self._xpath, attribute)

    ## This function returns the value of the specified entity attribute as an astropy scalar quantity
    # with given units. If the entity does not have the specified attribute, or if the attribute value does
    # not include a unit string, an error is raised.
    def getQuantityAttribute(self, attribute):
        return self._simulation.getQuantityAttribute(self._xpath, attribute)

    ## This function returns the value of the specified entity attribute as an astropy quantity array
    # with given units, assuming comma-separated values in the attribute value. If the entity does not have
    # the specified attribute, or if one of the attribute values does not include a unit string, an error is raised.
    def getQuantityListAttribute(self, attribute):
        return self._simulation.getQuantityListAttribute(self._xpath, attribute)

    ## This function returns a list of absolute paths to the output files associated with this entity.
    # If the \em fileType argument is present, the list is limited to files with a name with a final segment
    # (i.e. the portion after the simulation prefix an entity name) that ends in the specified string.
    # The returned list is sorted alphabetically on filename. The list may be empty.
    def outFilePaths(self, fileType=None):
        pattern = "{}_{}_*".format(self._simulation.prefix(), self.name())
        if fileType is not None:
            pattern += fileType
        return sorted(self._simulation.outDirPath().glob(pattern))

    ## This function returns an astropy quantity array containing the characteristic wavelengths of the
    # wavelength grid associated with this entity, or raises an error if this information cannot be obtained.
    # The function uses the following mechanisms for obtaining the wavelength grid, in the order listed,
    # until one is successful.
    #
    #   - If the simulation has an oligochromatic wavelength regime, read the wavelengths from the ski file
    #     (in this case all wavelength grids in the simulation are identical).
    #   - Load the "*_wavelengths.dat" file associated with this entity.
    #   - Load the "*_sed.dat" file associated with this entity.
    #   - Load any "*.dat" file associated with this entity that has an unambiguous "wavelength" column.
    #   - Load from any "*.fits" file associated with this entity that has a wavelength-compatible table extension.
    #
    # If all mechanisms fail, an error is raised.
    def wavelengths(self):
        # for oligochromatic simulations, get the wavelengths from the ski file
        if self._simulation.isOligo():
            return self._simulation.getQuantityListAttribute("//SourceSystem", "wavelengths")
        # try to load from "*_wavelengths.dat" file
        wavefilepaths = self.outFilePaths("wavelengths.dat")
        if len(wavefilepaths) == 1:
            return loadColumns(wavefilepaths[0], (0,))[0]
        # try to load from "*_sed.dat" file
        sedfilepaths = self.outFilePaths("sed.dat")
        if len(sedfilepaths) == 1:
            return loadColumns(sedfilepaths[0], (0,))[0]
        # try to load from any "*.dat" file with a "wavelength" column
        for filepath in self.outFilePaths(".dat"):
            try:
                return loadColumns(filepath, "wavelength")[0]
            except ValueError:
                pass
        # try to load from any "*.fits" file with a wavelength table extension
        for filepath in self.outFilePaths(".fits"):
            grids = getFitsAxes(filepath)
            if len(grids) > 2 and grids[2].unit.is_equivalent(u.m):
                return grids[2]
        # failed
        raise ValueError("Cannot obtain wavelengths for '{}_{}'".format(self._simulation.prefix(), self.name()))

    ## This function returns an astropy quantity array containing the wavelength bin widths of the
    # wavelength grid associated with this entity, or raises an error if this information cannot be obtained.
    # The function uses the following mechanisms for obtaining the wavelength bin widths, in the order listed,
    # until one is successful.
    #
    #   - Load the "*_wavelengths.dat" file associated with this entity.
    #   - If the simulation has an oligochromatic wavelength regime, read the wavelengths from the ski file
    #     and determine the fixed bin width as 1/500 of the shortest wavelength in the list (in this case all
    #     wavelength grids in the simulation are identical, and the bin widths are determined as here described).
    #
    # If all mechanisms fail, an error is raised.
    def wavelengthBinWidths(self):
        # try to load from "*_wavelengths.dat" file
        wavefilepaths = self.outFilePaths("wavelengths.dat")
        if len(wavefilepaths) == 1:
            return loadColumns(wavefilepaths[0], (1,))[0]
        # for oligochromatic simulations, get the wavelengths from the ski file
        if self._simulation.isOligo():
            waves = self._simulation.getQuantityListAttribute("//SourceSystem", "wavelengths")
            return np.repeat(waves.min()/500., len(waves))
        # failed
        raise ValueError("Cannot obtain wavelengths for '{}_{}'".format(self._simulation.prefix(), self.name()))

    ## This function uses the wavelengths() function to load the characteristic wavelengths of the
    # wavelength grid associated with this entity, and then determines the zero-based grid index corresponding
    # to (i.e. with a characteristic wavelength nearest to) each of the wavelengths specified as an argument.
    # The \em wavelengths argument must be an iterable of astropy quantities (including an astropy quantity array).
    # The function returns an iterable of integers with the same length.
    def wavelengthIndices(self, wavelengths):
        if wavelengths is not None:
            grid = self.wavelengths()
            return [ np.argmin(np.abs(grid-wave)) for wave in wavelengths ]
        else:
            return None

## An instance of the Instrument class can be spawned from a Simulation object to represent an instrument in the
# simulation, allowing to retrieve its attributes. See the Simulation.instruments() function.
class Instrument(_SimulationEntity):

    ## The constructor accepts the Simulation instance in which this instrument resides, and the zero-based index
    # of the instrument in the instrument system. It is intended to be invoked only from within the Simulation class.
    def __init__(self, simulation, index):
        super().__init__(simulation, "//InstrumentSystem/instruments/*[{}]".format(int(index)+1))

    ## This function returns the name of the instrument as specified in the ski file, as a string.
    def name(self):
        return self.getStringAttribute("instrumentName")

    ## For distant instruments (which use parallel projection), this function returns the distance of the instrument
    # to the model as an astropy scalar quantity with the length units specified in the ski file. If the instrument
    # does not have a distance attribute, or the distance attribute value does not include a unit string, the
    # function raises an error.
    def distance(self):
        return self.getQuantityAttribute("distance")

## An instance of the Probe class can be spawned from a Simulation object to represent a probe in the
# simulation, allowing to retrieve its attributes. See the Simulation.probes() function.
class Probe(_SimulationEntity):

    ## The constructor accepts the Simulation instance in which this probe resides, and the zero-based index
    # of the probe in the probe system. It is intended to be invoked only from within the Simulation class.
    def __init__(self, simulation, index):
        super().__init__(simulation, "//ProbeSystem/probes/*[{}]".format(int(index) + 1))

    ## This function returns the name of the probe as specified in the ski file, as a string.
    def name(self):
        return self.getStringAttribute("probeName")

# -----------------------------------------------------------------
